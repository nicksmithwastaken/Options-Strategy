Here is the detailed breakdown of the technical specification into numbered, 1-story-point tasks with checkboxes for an AI coding agent, based on our plan:
Task: Initialize Next.js Project with TypeScript and Tailwind CSS
[ ] Run create-next-app with the project name, selecting TypeScript, Tailwind CSS, and App Router.
[ ] Configure tsconfig.json for strict type checking.
[ ] Verify Tailwind CSS installation by adding basic utility classes to the home page.
Task: Configure ESLint and Prettier
[ ] Install necessary ESLint and Prettier dependencies for Next.js, TypeScript, and Tailwind CSS.
[ ] Create or update .eslintrc.json and .prettierrc.json configuration files.
[ ] Add lint and format scripts to package.json.
Task: Set up Environment Variables
[ ] Create .env.local file in the project root.
[ ] Add placeholder variables for NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, RESEND_API_KEY, and MARKET_DATA_API_KEY.
Task: Create Supabase Project (Verification/Configuration)
[ ] (Note: This step is manual in the Supabase UI) Verify that a Supabase project has been created.
[ ] Obtain the Project URL and anon and service_role keys from the Supabase dashboard.
[ ] Add the obtained keys to the .env.local file.
Task: Configure Supabase Email Authentication (Verification/Configuration)
[ ] (Note: This step is manual in the Supabase UI) Verify that Email Authentication is enabled in Supabase Auth settings.
[ ] (Note: Email templates will be configured later with Resend) Acknowledge that email templates need configuration.
Task: Configure Supabase Third-Party Authentication (Optional Verification/Configuration)
[ ] (Note: This step is manual in the Supabase UI) Verify if any third-party providers (e.g., Google) are enabled in Supabase Auth settings based on project requirements.
Task: Design and Create users Table Schema (Supabase)
[ ] Write the SQL migration or use the Supabase UI to ensure the users table exists (standard auth table).
[ ] Add an id column (UUID, Primary Key, linked to auth.users).
[ ] Add a created_at column (TIMESTAMPZ, with default now()).
[ ] Implement RLS policy to allow users to SELECT, INSERT, UPDATE, DELETE their own users row based on auth.uid().
Task: Design and Create brokerages Table Schema (Supabase)
[ ] Write the SQL migration or use the Supabase UI to create the brokerages table.
[ ] Add an id column (UUID, Primary Key, default gen_random_uuid()).
[ ] Add a name column (TEXT, NOT NULL).
[ ] Add an api_base_url column (TEXT, NOT NULL).
[ ] Add an auth_type column (TEXT, NOT NULL, e.g., 'oauth', 'api_key').
[ ] Implement RLS policy to allow authenticated users to SELECT from this table.
Task: Design and Create user_brokerage_accounts Table Schema (Supabase)
[ ] Write the SQL migration or use the Supabase UI to create the user_brokerage_accounts table.
[ ] Add an id column (UUID, Primary Key, default gen_random_uuid()).
[ ] Add a user_id column (UUID, NOT NULL, FK to users.id).
[ ] Add a brokerage_id column (UUID, NOT NULL, FK to brokerages.id).
[ ] Add a brokerage_account_id column (TEXT, NOT NULL) - Unique identifier from the brokerage.
[ ] Add access_token, refresh_token (TEXT, nullable, store securely, potentially encrypted).
[ ] Add expires_at (TIMESTAMPZ, nullable).
[ ] Add created_at (TIMESTAMPZ, default now()).
[ ] Add updated_at (TIMESTAMPZ, default now()).
[ ] Implement RLS policy to allow users to SELECT, INSERT, UPDATE, DELETE their own user_brokerage_accounts rows based on auth.uid() = user_id.
Task: Design and Create trades Table Schema (Supabase - Initial)
[ ] Write the SQL migration or use the Supabase UI to create the trades table.
[ ] Add id (UUID, Primary Key, default gen_random_uuid()).
[ ] Add user_id (UUID, NOT NULL, FK to users.id).
[ ] Add brokerage_account_id (UUID, nullable, FK to user_brokerage_accounts.id).
[ ] Add brokerage_trade_id (TEXT, nullable).
[ ] Add trade_type (TEXT, NOT NULL, consider using a PostgreSQL ENUM type later).
[ ] Add underlying_ticker (TEXT, NOT NULL).
[ ] Add option_type (TEXT, nullable, 'call' or 'put').
[ ] Add strike_price (NUMERIC, nullable).
[ ] Add expiration_date (DATE, nullable).
[ ] Add contracts (INTEGER, NOT NULL).
[ ] Add premium_per_contract (NUMERIC, NOT NULL).
[ ] Add total_premium (NUMERIC, NOT NULL).
[ ] Add trade_date (TIMESTAMPZ, NOT NULL).
[ ] Add notes (TEXT, nullable).
[ ] Add strategy_tag (TEXT, nullable).
[ ] Add status (TEXT, NOT NULL, 'open', 'closed', 'assigned', 'expired', consider ENUM).
[ ] Add created_at (TIMESTAMPZ, default now()).
[ ] Add updated_at (TIMESTAMPZ, default now()).
Task: Design and Create assignments Table Schema (Supabase - Initial)
[ ] Write the SQL migration or use the Supabase UI to create the assignments table.
[ ] Add id (UUID, Primary Key, default gen_random_uuid()).
[ ] Add user_id (UUID, NOT NULL, FK to users.id).
[ ] Add put_trade_id (UUID, NOT NULL, FK to trades.id).
[ ] Add assignment_date (TIMESTAMPZ, NOT NULL).
[ ] Add shares_received (INTEGER, NOT NULL).
[ ] Add cost_basis_per_share (NUMERIC, NOT NULL).
[ ] Add total_cost_basis (NUMERIC, NOT NULL).
[ ] Add created_at (TIMESTAMPZ, default now()).
[ ] Implement RLS policy to allow users to SELECT, INSERT, UPDATE, DELETE their own assignments rows based on auth.uid() = user_id.
Task: Design and Create watchlist Table Schema (Supabase)
[ ] Write the SQL migration or use the Supabase UI to create the watchlist table.
[ ] Add id (UUID, Primary Key, default gen_random_uuid()).
[ ] Add user_id (UUID, NOT NULL, FK to users.id).
[ ] Add ticker (TEXT, NOT NULL).
[ ] Add created_at (TIMESTAMPZ, default now()).
[ ] Add a unique constraint on (user_id, ticker).
[ ] Implement RLS policy to allow users to SELECT, INSERT, DELETE their own watchlist rows based on auth.uid() = user_id.
Task: Implement RLS for trades Table
[ ] Write the SQL to enable RLS on the trades table.
[ ] Create a policy to allow authenticated users to SELECT rows where user_id = auth.uid().
[ ] Create a policy to allow authenticated users to INSERT rows where user_id = auth.uid().
[ ] Create a policy to allow authenticated users to UPDATE rows where user_id = auth.uid().
[ ] Create a policy to allow authenticated users to DELETE rows where user_id = auth.uid().
Task: Install Shadcn UI and Initialize Components
[ ] Install Shadcn UI CLI (npm install -D shadcn-ui@latest).
[ ] Run npx shadcn-ui@latest init and configure it for Next.js App Router, TypeScript, and Tailwind CSS.
[ ] Run npx shadcn-ui@latest add button input label card table form dialog sheet navigation-menu to add initial required components.
Task: Install Lucide Icons
[ ] Install lucide-react (npm install lucide-react).
Task: Verify Tailwind CSS Configuration
[ ] Check tailwind.config.ts to ensure content includes paths to Shadcn UI components (./components/**/*.{js,ts,jsx,tsx,mdx}, ./app/**/*.{js,ts,jsx,tsx,mdx}).
[ ] Verify globals.css includes the necessary Tailwind directives (@tailwind base;, @tailwind components;, @tailwind utilities;).
Task: Install Framer Motion
[ ] Install framer-motion (npm install framer-motion).
Task: Configure Resend API Key (Verification/Configuration)
[ ] (Note: This step is manual in the Resend UI) Verify that a Resend API key has been obtained.
[ ] Add the Resend API key to the .env.local file (RESEND_API_KEY).
Task: Create Main Application Layout
[ ] Create the root layout file (app/layout.tsx).
[ ] Implement the basic HTML structure (<html>, <body>).
[ ] Include necessary meta tags and link the global CSS file.
[ ] Wrap the main content (children) with a container div.
Task: Implement Responsive Header Navigation (Initial)
[ ] Create a components/layout/header.tsx component.
[ ] Use Shadcn UI components (e.g., div, Button, Sheet for mobile).
[ ] Add a simple logo/app title.
[ ] Include placeholder navigation links (e.g., Dashboard, Log Trade) using Next.js Link.
[ ] Use Lucide Icons for any toggle buttons (e.g., mobile menu).
[ ] Integrate the Header component into the main layout.
Task: Implement Responsive Sidebar Navigation (Initial - Optional Alternative/Complement)
[ ] Create a components/layout/sidebar.tsx component.
[ ] Use Shadcn UI components and Lucide Icons for navigation items.
[ ] Implement responsiveness (e.g., hidden on mobile, visible on desktop).
[ ] Integrate the Sidebar component into the main layout structure alongside the content area.
Task: Create Login Page UI (/login)
[ ] Create the page file (app/login/page.tsx).
[ ] Build a basic login form using Shadcn UI Card, Form, Input, Label, and Button.
[ ] Include fields for Email and Password.
[ ] Add links to "Sign Up" and "Forgot Password".
Task: Implement Login Form Client-Side Validation
[ ] Install react-hook-form and zod (npm install react-hook-form zod @hookform/resolvers).
[ ] Define a Zod schema for the login form fields (email, password).
[ ] Integrate react-hook-form with the login form component.
[ ] Apply Zod resolver for validation.
[ ] Display validation error messages using Shadcn UI styling.
Task: Implement Login Authentication Logic (Supabase)
[ ] Create a client-side Supabase client instance within the login page or a dedicated hook.
[ ] Implement the form submission handler.
[ ] Call supabase.auth.signInWithPassword using the form data.
[ ] Handle successful login (redirect to dashboard) and display errors (e.g., using a toast notification, requires Shadcn UI Toast setup).
Task: Create Signup Page UI (/signup)
[ ] Create the page file (app/signup/page.tsx).
[ ] Build a basic signup form using Shadcn UI Card, Form, Input, Label, and Button.
[ ] Include fields for Email and Password. (Consider Confirm Password if needed).
[ ] Add a link to "Login".
Task: Implement Signup Form Client-Side Validation
[ ] Define a Zod schema for the signup form fields (email, password, confirm password if used).
[ ] Integrate react-hook-form with the signup form component.
[ ] Apply Zod resolver for validation.
[ ] Display validation error messages.
Task: Implement Signup Authentication Logic (Supabase)
[ ] Create a client-side Supabase client instance.
[ ] Implement the form submission handler.
[ ] Call supabase.auth.signUp using the form data, specifying the redirect URL for email confirmation.
[ ] Handle successful signup (show confirmation message) and display errors.
Task: Create Forgot Password Page UI (/forgot-password)
[ ] Create the page file (app/forgot-password/page.tsx).
[ ] Build a form with an Email input field and a submit button.
[ ] Add a link back to "Login".
Task: Implement Forgot Password Logic (Supabase)
[ ] Create a client-side Supabase client instance.
[ ] Implement the form submission handler.
[ ] Call supabase.auth.resetPasswordForEmail using the email address, specifying the redirect URL after password reset.
[ ] Handle success (show confirmation message) and display errors.
Task: Implement Protected Routes Middleware
[ ] Create a middleware.ts file in the project root.
[ ] Use Supabase Auth helpers middleware to protect application routes (e.g., /dashboard, /log-trade, etc.), redirecting unauthenticated users to /login.
Task: Set up Supabase Client Instances (Server and Client)
[ ] Create a helper file (e.g., utils/supabase/client.ts) to create a client-side Supabase client instance using createBrowserClient.
[ ] Create a helper file (e.g., utils/supabase/server.ts) to create a server-side Supabase client instance using createServerClient.
[ ] Ensure client instances are configured to read/write cookies for session management.
Task: Create Market Data API Route for Options Chain
[ ] Create a new API route file (e.g., app/api/marketdata/options-chain/route.ts).
[ ] Implement a GET request handler.
[ ] Read the ticker and expiration date from request query parameters.
[ ] Call the external market data API endpoint to fetch the options chain data for the specified ticker and date.
[ ] Handle API key authentication for the external API securely on the server side.
[ ] Return the fetched options chain data as a JSON response.
[ ] Implement basic error handling for API calls and invalid input.
Task: Create Market Data API Route for Quote/Greeks/Volume
[ ] Create a new API route file (e.g., app/api/marketdata/quote/route.ts).
[ ] Implement a GET request handler.
[ ] Read the ticker, option type, strike, and expiration from query parameters.
[ ] Call the external market data API endpoint to fetch the latest quote, volume, and Greeks for the specific option contract.
[ ] Return the fetched data as a JSON response.
[ ] Implement basic error handling.
Task: Implement Basic Caching for Market Data API Routes
[ ] For the options chain and quote API routes, implement a simple caching mechanism (e.g., in-memory cache for a short duration) to avoid hitting the external API excessively for frequent requests for the same data. Consider data freshness requirements.
Task: Define TypeScript Interfaces for Market Data
[ ] Create a file (e.g., types/marketdata.ts).
[ ] Define TypeScript interfaces that match the expected structure of the responses from the market data API for options chains, quotes, volume, and Greeks.
Task: Create Supabase Data Access Functions for trades
[ ] Create a file (e.g., lib/data/trades.ts).
[ ] Write asynchronous functions to perform CRUD operations on the trades table using the Supabase client:
getTrades(userId, status): Fetch trades filtered by user and status.
createTrade(tradeData): Insert a new trade record.
updateTrade(tradeId, updateData): Update an existing trade record.
deleteTrade(tradeId): Delete a trade record.
Ensure functions use the server-side Supabase client where appropriate (e.g., in server components or API routes) and handle RLS implicitly.
Task: Create Supabase Data Access Functions for assignments
[ ] Create a file (e.g., lib/data/assignments.ts).
[ ] Write asynchronous functions for assignments table:
getAssignments(userId): Fetch assignments for a user.
createAssignment(assignmentData): Insert a new assignment record.
Link these functions to trades data access where relevant (e.g., fetching assignments related to a put trade).
Task: Create Supabase Data Access Functions for watchlist
[ ] Create a file (e.g., lib/data/watchlist.ts).
[ ] Write asynchronous functions for watchlist table:
getWatchlist(userId): Fetch user's watchlist tickers.
addWatchlistTicker(userId, ticker): Add a ticker to the watchlist.
removeWatchlistTicker(userId, ticker): Remove a ticker from the watchlist.
Task: Create Supabase Data Access Functions for user_brokerage_accounts
[ ] Create a file (e.g., lib/data/brokerage.ts).
[ ] Write asynchronous functions for user_brokerage_accounts:
getUserBrokerageAccounts(userId): Fetch connected brokerage accounts for a user.
createUserBrokerageAccount(accountData): Save new connected account details (including tokens).
updateUserBrokerageAccount(accountId, updateData): Update account details (e.g., tokens, last sync time).
deleteUserBrokerageAccount(accountId): Remove a connected account.
Task: Create Trade Entry Page Structure (/log-trade)
[ ] Create the page file (app/log-trade/page.tsx).
[ ] Implement the basic page layout using Shadcn UI containers/cards.
[ ] Add sections for Ticker Input, Options Chain Display, Automated Analysis Results, and Trade Details Form.
Task: Implement Ticker Search Input with Autocomplete
[ ] In the Trade Entry page, add an Input component for the ticker symbol.
[ ] Implement a debounced input handler.
[ ] When the user types, call your market data API route (/api/marketdata/search-ticker - requires creating this route) to fetch ticker suggestions.
[ ] Display suggestions as a dropdown list.
Task: Implement Options Chain Display Table
[ ] In the Trade Entry page, create a table component (using Shadcn UI Table) to display the options chain data.
[ ] Add columns for Strike, Expiration, Call/Put indicators, and placeholder columns for Volume/Greeks (will populate later).
[ ] Implement state to store the fetched options chain data.
Task: Implement Strike/Expiration Selection Handlers
[ ] Add click handlers to the rows or specific cells in the Options Chain table.
[ ] When a user clicks a strike/expiration/type combination, update the component's state to reflect the selected option contract.
Task: Implement Market Data Fetching on Strike Selection
[ ] Add a useEffect or similar mechanism that triggers when the selected option contract state changes.
[ ] Inside the effect, call your market data API route (/api/marketdata/quote) with the details of the selected contract (ticker, type, strike, expiration).
[ ] Store the fetched quote, volume, and Greeks data in the component's state.
Task: Implement ROC Calculation Logic
[ ] Create a helper function (e.g., lib/calculations.ts) to calculate Return on Capital.
[ ] Formula: ROC = (Total Premium Received / (Strike Price * Contracts * 100)) * 100 (for Cash Secured Puts). Adjust formula for other trade types.
[ ] This function should take necessary inputs (premium, strike, contracts).
Task: Implement Annual ROC Calculation Logic
[ ] In the lib/calculations.ts file, create a helper function for Annual ROC.
[ ] Formula: Annual ROC = ROC * (365 / Days to Expiration).
[ ] This function requires the Days to Expiration, which needs to be calculated based on the selected expiration date and the current date.
Task: Implement ITM/OTM Distance Calculation Logic
[ ] In lib/calculations.ts, create a helper function for ITM/OTM distance.
[ ] Formula: Distance = Current Underlying Price - Strike Price.
[ ] Indicate if it's ITM (>0 for Call, <0 for Put), OTM (<0 for Call, >0 for Put), or ATM (=0). Display as absolute distance and percentage. This requires fetching the current underlying price.
Task: Display Automated Analysis Metrics on Trade Entry Form
[ ] In the Trade Entry page UI, create a dedicated section to display the calculated ROC, Annual ROC, ITM/OTM Distance, fetched Volume, and fetched Greeks (Delta, Gamma, Theta, Vega).
[ ] Update this section whenever a new option contract is selected and market data is fetched. Use Shadcn UI Card or similar for presentation.
Task: Build Additional Trade Entry Input Fields
[ ] Add input fields for:
Number of Contracts (Integer)
Premium Paid/Received per Contract (Numeric)
Trade Date and Time (Use a date/time picker component, e.g., from a library compatible with react-hook-form and Shadcn UI)
Notes (Textarea)
Strategy Tag (Text input or dropdown/tags component)
[ ] Integrate these fields with react-hook-form for state management and validation.
Task: Implement Trade Entry Form Submission and Supabase Save
[ ] Implement the form submission handler for the main trade entry form.
[ ] Collect all data: selected ticker, option details, contracts, premium, date, notes, tags, and the calculated total_premium.
[ ] Determine the initial status (likely 'open').
[ ] Call the createTrade Supabase data access function, passing the formatted trade data.
[ ] Handle success (e.g., show a success toast, redirect to Active Trades) and display errors.
Task: Create Brokerage Integration Page Structure (/brokerage)
[ ] Create the page file (app/brokerage/page.tsx).
[ ] Implement the basic page layout.
[ ] Add sections for "Supported Brokerages" and "Connected Accounts."
Task: Display List of Supported Brokerages UI
[ ] In the "Supported Brokerages" section, fetch the list of supported brokers from your brokerages table in Supabase.
[ ] Display them as a list or grid using Shadcn UI components (e.g., Card).
[ ] Include the brokerage name and an icon (Lucide Icons).
[ ] Add a button (e.g., "Connect") for each brokerage.
Task: Implement Brokerage OAuth Flow Initiation
[ ] For brokerages with auth_type = 'oauth', implement the click handler for the "Connect" button.
[ ] Construct the OAuth authorization URL based on the brokerage's API documentation and the api_base_url from your brokerages table. Include necessary parameters (client ID, redirect URI, scope, state).
[ ] Redirect the user's browser to this authorization URL.
Task: Create Brokerage OAuth Callback API Route
[ ] Create a new API route file (e.g., app/api/brokerage/[brokerageId]/callback/route.ts) to handle the redirect from the brokerage's OAuth server.
[ ] Implement a GET request handler.
[ ] Extract the authorization code and state parameter from the request URL.
[ ] Implement state verification to prevent CSRF attacks.
[ ] Exchange the authorization code for access and refresh tokens by making a POST request to the brokerage's token endpoint.
Task: Implement Secure Token Storage for Brokerage
[ ] After successfully obtaining access and refresh tokens in the OAuth callback API route, securely store them in the user_brokerage_accounts table using your createUserBrokerageAccount Supabase data access function.
[ ] Associate the account with the currently logged-in user (auth.uid()).
[ ] Redirect the user back to the Brokerage Integration page or a success page within your application.
Task: Implement Secure API Key Form (if needed)
[ ] For brokerages with auth_type = 'api_key', implement a form on the Brokerage Integration page to securely capture the API key(s).
[ ] Implement a server-side API route to receive the submitted API key(s).
[ ] Store the API key(s) securely in the user_brokerage_accounts table, potentially using encryption at rest in your database or a secrets manager.
Task: Implement Manual Brokerage Data Sync Trigger UI
[ ] On the Brokerage Integration page, for each connected account, add a button (e.g., "Sync Now").
Task: Implement Server-Side Brokerage Data Fetching Logic
[ ] Create a server-side function (e.g., lib/brokerage/sync.ts) that takes a user_brokerage_account ID as input.
[ ] Retrieve the account's credentials (tokens/keys) from the database.
[ ] Use the credentials to call the brokerage's API endpoints to fetch historical and recent trade executions. Handle pagination if necessary.
[ ] Implement token refresh logic if using OAuth and the access token is expired.
Task: Implement Brokerage Data Mapping to trades Schema
[ ] Within the server-side sync function, map the data structure received from the brokerage API for trade executions to your application's trades table schema.
[ ] Handle variations in how different brokers represent trade data.
Task: Implement Brokerage Data Mapping to assignments Schema
[ ] Within the server-side sync function, identify assignment events from the brokerage data.
[ ] Map the assignment data to your application's assignments table schema (or update the relevant trades record if integrating assignment there).
Task: Implement Logic to Avoid Duplicate Brokerage Imports
[ ] During the sync process, before inserting a trade or assignment, check if a record with the same brokerage_account_id and brokerage_trade_id already exists in your database.
[ ] If it exists, skip insertion or update the existing record if necessary (e.g., status change).
Task: Display Connected Brokerage Accounts Status UI
[ ] In the "Connected Accounts" section of the Brokerage Integration page, fetch the user's user_brokerage_accounts from Supabase.
[ ] Display each connected account, showing the brokerage name, the account ID from the brokerage, and the time of the last successful sync.
Task: Create Active Trades Page Structure (/active-trades)
[ ] Create the page file (app/active-trades/page.tsx).
[ ] Implement the basic page layout.
[ ] Add a section to display the table of active trades.
Task: Fetch and Display Active Trades Table (Basic)
[ ] In the Active Trades page, fetch active trades (status = 'open') for the logged-in user using your getTrades Supabase data access function.
[ ] Display the trades in a Shadcn UI Table. Include columns for Ticker, Strike, Expiration, Quantity, Entry Premium, Entry Date, and Source (Manual/Brokerage).
Task: Implement Real-time Value Calculation for Active Trades
[ ] For each trade displayed in the Active Trades table, fetch the latest market data (current underlying price and option price/Greeks) using your market data API routes.
[ ] Calculate the current market value of the option position (Current Option Price * Contracts * 100).
Task: Implement Real-time P/L Calculation for Active Trades
[ ] For each trade, calculate the running Profit or Loss.
[ ] Formula (for a simple put sell): Running P/L = (Entry Premium - Current Option Price) * Contracts * 100. Adjust for calls and other trade types.
Task: Display Real-time Value and P/L in Active Trades Table
[ ] Add columns to the Active Trades table to display the calculated "Current Value" and "Running P/L ($ and %)".
[ ] Implement logic to update these values periodically (e.g., client-side polling the market data API every few seconds/minutes, or use WebSockets if available and supported by the API).
Task: Implement Sorting/Filtering for Active Trades Table
[ ] Add controls (e.g., dropdowns, input fields) above the Active Trades table to allow filtering by Ticker, Expiration Date, or Source.
[ ] Implement sorting functionality for table columns (e.g., sort by Ticker, Expiration, Running P/L).
Task: Add "Close Trade" Action Button in Active Trades Table
[ ] Add a button or icon (Lucide Icons) in each row of the Active Trades table to initiate the "Close Trade" action.
Task: Implement Close Trade Logic (Manual Input Modal UI)
[ ] Create a Shadcn UI Dialog component for the manual trade closing form.
[ ] Include fields for Closing Date/Time and Premium Paid/Received.
[ ] Integrate react-hook-form for validation.
[ ] Display this modal when the "Close Trade" button is clicked for a manually entered trade or if brokerage detection fails.
Task: Implement Close Trade Logic (Brokerage Detection)
[ ] When the "Close Trade" button is clicked for a trade linked to a brokerage, call a server-side function/API route.
[ ] This function should use the stored brokerage credentials to query the brokerage API for recent executions related to that specific open position.
[ ] If a matching closing execution is found, retrieve the closing details (date, price).
Task: Implement Final P/L Calculation on Trade Close
[ ] Create a helper function to calculate the final P/L based on entry details and closing details (either manual input or brokerage data).
[ ] Formula (for a simple put sell): Final P/L = (Entry Premium - Closing Premium) * Contracts * 100. Adjust for calls, assignments, etc.
Task: Update Trade Status to 'closed' in Supabase
[ ] After calculating the final P/L and confirming closing details, call your updateTrade Supabase data access function.
[ ] Update the status field to 'closed', store the closing date/time, closing premium, and the calculated final P/L in the trades table (may require adding new columns like closing_date, closing_premium, final_pl).
Task: Create Trade History Page Structure (/trade-history)
[ ] Create the page file (app/trade-history/page.tsx).
[ ] Implement the basic page layout.
[ ] Add a section to display the table of closed trades.
Task: Fetch and Display Closed Trades Table (Basic)
[ ] In the Trade History page, fetch closed trades (status = 'closed') for the logged-in user using your getTrades Supabase data access function.
[ ] Display the trades in a Shadcn UI Table. Include columns for Entry Details, Exit Details, Final P/L, and Source.
Task: Implement Sorting/Filtering for Trade History Table
[ ] Add controls above the Trade History table for filtering by Date Range, Ticker, Strategy Tag, and Source.
[ ] Implement sorting functionality for table columns (e.g., sort by Trade Date, Ticker, Final P/L).
Task: Create Performance / Analytics Page Structure (/performance)
[ ] Create the page file (app/performance/page.tsx).
[ ] Implement the basic page layout using Shadcn UI containers/cards to structure different sections (Summary Metrics, Charts, etc.).
Task: Fetch Data for Performance Metrics
[ ] In the Performance page (likely a server component for initial data load), fetch all closed trade data for the logged-in user from Supabase.
Task: Implement Performance Metric Calculation Logic
[ ] Create helper functions to calculate aggregated performance metrics from the fetched trade data:
Total Realized P/L (Sum of final_pl for all closed trades)
Win Rate (Count of profitable trades / Total closed trades)
Average Winning Trade P/L
Average Losing Trade P/L
(Wheel Specific) Total Premium Collected Across all trades/cycles
(Wheel Specific) Average P/L per Wheel Cycle (requires linking trades into cycles)
Task: Display Performance Metrics UI
[ ] In the Performance page UI, display the calculated summary metrics using Shadcn UI Card components. Use clear labels and formatting.
Task: Integrate Charting Library
[ ] Install a React-compatible charting library (e.g., Recharts: npm install recharts).
Task: Implement Equity Curve Chart
[ ] Create a React component for the Equity Curve chart using the chosen charting library.
[ ] The chart data should represent the cumulative P/L over time, based on the trade_date and final_pl of closed trades.
[ ] Integrate the chart component into the Performance page, placing it within a Shadcn UI Card.
Task: Implement P/L by Strategy Chart
[ ] Create a chart component to visualize P/L grouped by strategy_tag. A bar chart or pie chart could work.
[ ] Calculate the total P/L for each unique strategy tag from closed trades.
[ ] Integrate the chart into the Performance page.
Task: Implement P/L by Underlying Ticker Chart
[ ] Create a chart component to visualize P/L grouped by underlying_ticker. A bar chart is suitable.
[ ] Calculate the total P/L for each ticker from closed trades.
[ ] Integrate the chart into the Performance page.
Task: Implement Wins vs Losses Distribution Chart
[ ] Create a chart component (e.g., a bar chart or pie chart) showing the count or percentage of winning trades vs. losing trades.
Task: Implement Performance Dashboard Filtering Logic
[ ] Add filtering controls (e.g., date range picker, strategy tag dropdown, ticker dropdown) on the Performance page.
[ ] Implement logic to refetch or re-process the trade data based on the selected filters, updating the displayed metrics and charts accordingly.
Task: Create Watchlist Page Structure (/watchlist)
[ ] Create the page file (app/watchlist/page.tsx).
[ ] Implement the basic page layout.
[ ] Add sections for adding tickers and displaying the current watchlist.
Task: Implement Ticker Search for Watchlist
[ ] In the Watchlist page, add an Input component for searching tickers, similar to the Trade Entry page.
[ ] Implement debounced input and call the market data API route (/api/marketdata/search-ticker) for suggestions.
Task: Implement Add Ticker to Watchlist Logic (Supabase Save)
[ ] Add a button (e.g., "Add to Watchlist") next to ticker search results or in the Watchlist section.
[ ] Implement the click handler to call your addWatchlistTicker Supabase data access function, saving the ticker and user ID.
[ ] Handle potential errors (e.g., ticker already exists in watchlist).
Task: Display Watchlist Tickers List
[ ] Fetch the user's watchlist tickers using getWatchlist Supabase data access function.
[ ] Display the tickers in a list or table.
Task: Fetch and Display Current Price for Watchlist Tickers
[ ] For each ticker in the displayed watchlist, fetch its current price using your market data API route (/api/marketdata/quote).
[ ] Display the current price next to the ticker symbol. Consider efficient fetching (e.g., fetching quotes for all watchlist tickers in one API call if the external API supports batching).
Task: Add Link/Button to View Options Chain from Watchlist
[ ] Add a button or link next to each watchlist ticker.
[ ] This action should navigate the user to the Trade Entry page (/log-trade) with the ticker pre-filled, or display the options chain in a modal/sidebar.
Task: Implement Remove Ticker from Watchlist Logic
[ ] Add a button or icon (e.g., 'x') next to each watchlist ticker.
[ ] Implement the click handler to call your removeWatchlistTicker Supabase data access function, deleting the ticker from the watchlist.
Task: Refine trades Table Schema for Wheel Linking
[ ] Add columns to the trades table to explicitly link legs of a Wheel:
wheel_cycle_id (UUID, nullable, FK to a new wheel_cycles table or self-referencing FK on trades if modeling cycles differently).
assigned_put_trade_id (UUID, nullable, FK to trades.id) - Link a Covered Call trade back to the Put that got assigned.
[ ] (Alternative) Revisit the schema design to potentially use a wheel_cycles table to group related trades.
Task: Implement Trade Linking Logic during Entry/Import
[ ] Modify the Trade Entry form and Brokerage Import logic to allow/attempt to link trades to existing Wheel cycles or previous legs (e.g., when logging a Covered Call, allow linking it to an Assignment or original Put trade).
Task: Implement Assignment Handling Logic (Status Update, Assignment Record)
[ ] When a Put Sell trade's status changes to 'assigned' (either manually or via brokerage sync), update the status in the trades table.
[ ] Create a new record in the assignments table, linking it to the put_trade_id. Calculate and store the cost_basis_per_share and total_cost_basis.
Task: Implement Covered Call Linking Logic
[ ] When logging or importing a Covered Call trade, if it's related to a previous assignment, implement logic to link it to the corresponding assignment record or the original Put trade using the new FK columns.
Task: Implement Adjusted Cost Basis Calculation
[ ] Create a helper function to calculate the adjusted cost basis for shares obtained via assignment, factoring in the premium received for the put.
[ ] Formula: Adjusted Cost Basis Per Share = Put Strike Price - (Put Premium Received Per Share).
Task: Implement Total Wheel Cycle Premium Calculation
[ ] Create a function that, given a starting Put Sell trade or a wheel_cycle_id, fetches all linked trades (Put Sell, Assignments, Covered Calls).
[ ] Calculate the total premium collected across all legs in that cycle.
Task: Implement Wheel Cycle Status Tracking Logic
* [ ] Based on the linked trades within a cycle, determine the current status of the Wheel (e.g., "Put Open," "Assigned - Selling Calls," "Shares Called Away," "Cycle Closed"). Store this status if using a wheel_cycles table, or derive it on the fly.
Task: Display Wheel Specific Metrics on Performance Dashboard
* [ ] Modify the Performance dashboard to include metrics specifically relevant to the Wheel Strategy, calculated using the functions from tasks 98-100. Examples: Average Premium per Put, Average Premium per Call, Average Adjusted Cost Basis, Average P/L per Cycle.
Task: (Optional) Create Dedicated Wheel Cycles View
* [ ] Create a new page (/wheel-cycles) to list all active and completed Wheel cycles.
* [ ] For each cycle, display its current status, the underlying ticker, the initial put strike, and key cycle-specific metrics (e.g., total premium collected so far, adjusted cost basis).
* [ ] Allow clicking into a cycle to see all linked trades.
Task: Implement Premium Collected vs Assignment Cost Chart
* [ ] Create a chart component (e.g., a bar chart or scatter plot) on the Performance or Wheel Cycles page to visualize the relationship between premium collected and the cost basis from assignment for completed cycles.
Task: Integrate Resend API Client
* [ ] Install the Resend SDK (npm install resend).
* [ ] Create a helper function or class to interact with the Resend API, using the RESEND_API_KEY environment variable.
Task: Implement Account Confirmation Email Sending via Resend
* [ ] Configure Supabase to use a custom SMTP server or webhook to send authentication emails.
* [ ] Create a Next.js API route or Supabase Function that receives the email event from Supabase.
* [ ] Use the Resend SDK within this function to send the account confirmation email, formatting it nicely.
Task: Implement Password Reset Email Sending via Resend
* [ ] Similar to account confirmation, configure Supabase to trigger an event or use a custom SMTP setting for password reset emails.
* [ ] Use the Resend SDK to send the password reset email via your handler.
Task: (Advanced) Implement Logic for Upcoming Expiration Notifications
* [ ] Implement a mechanism (e.g., a Supabase scheduled function/job or an external cron job calling an API route) to periodically check active trades.
* [ ] Identify open option trades with expiration dates approaching (e.g., within 7 days).
* [ ] For identified trades, use the Resend SDK to send an email notification to the user about the upcoming expiration.
Task: (Advanced) Implement Logic for Potential Assignment Notifications
* [ ] Implement a mechanism (scheduled job/function) to check active Cash Secured Put trades.
* [ ] Fetch the current underlying price for these tickers.
* [ ] If the underlying price is below the strike price (ITM), send a notification to the user about the potential for assignment using Resend.
Task: Implement Basic Page Transition Animations (Framer Motion)
* [ ] Wrap page content in framer-motion components.
* [ ] Implement simple entrance/exit animations (e.g., fade, slide) for page transitions using AnimatePresence.
Task: Implement Component Mount Animations (Framer Motion)
* [ ] Identify key UI components (e.g., Cards on the dashboard, table rows).
* [ ] Wrap them in framer-motion components and apply initial mount animations (e.g., fade-in, slight scale-up).
Task: Implement Data Update Animations (Framer Motion)
* [ ] For displayed metrics on the dashboard or active trades (e.g., P/L numbers), use framer-motion or a similar library to animate the number changes smoothly when data updates.
Task: Ensure all Core Pages are Responsive (Tailwind CSS)
* [ ] Review the Dashboard, Log Trade, Active Trades, Trade History, Performance, and Watchlist pages.
* [ ] Use Tailwind CSS responsive utility prefixes (e.g., sm:, md:, lg:) to adjust layout, spacing, and component visibility for different screen sizes.
Task: Implement Robust Error Handling for Market Data API Calls
* [ ] In the API routes and client-side fetching logic for market data, add comprehensive try...catch blocks.
* [ ] Handle different types of API errors (e.g., rate limits, invalid ticker, server errors) and return appropriate error responses or display user-friendly error messages.
Task: Implement Robust Error Handling for Brokerage API Calls
* [ ] In the brokerage integration and sync logic, add comprehensive error handling for API calls to brokerages.
* [ ] Handle authentication errors (expired tokens - implement refresh logic), rate limits, and brokerage-specific errors.
* [ ] Log errors on the server side and provide feedback to the user in the UI.
Task: Implement Robust Error Handling for Supabase Operations
* [ ] In all Supabase data access functions, add error handling for database operations (e.g., insertion failures, RLS violations).
* [ ] Log errors on the server side and return/display appropriate error messages to the user.
Task: Implement Loading States for Data Fetching
* [ ] For components that fetch data (e.g., Active Trades table, Performance charts, Options Chain), display loading indicators (Shadcn UI Spinner or skeleton components) while data is being fetched.
Task: Implement Client-Side Form Validation (using Zod/react-hook-form)
* [ ] Ensure all forms (Login, Signup, Forgot Password, Trade Entry, etc.) have client-side validation implemented using Zod schemas and react-hook-form resolvers.
* [ ] Display validation errors clearly to the user before submission.
Task: Implement Server-Side Input Validation (using Zod)
* [ ] In Next.js API routes or server actions that receive user input (e.g., trade submission, watchlist add), re-validate the incoming data on the server side using the same Zod schemas used on the client. This is crucial for security and data integrity.
Task: Set up Jest for Unit Testing
* [ ] Install Jest and necessary types (npm install --save-dev jest @types/jest ts-jest).
* [ ] Configure Jest for a Next.js TypeScript project.
Task: Write Unit Tests for Calculation Logic
* [ ] Write Jest tests for the helper functions in lib/calculations.ts (ROC, Annual ROC, ITM/OTM, Adjusted Cost Basis, etc.) with various test cases.
Task: Write Unit Tests for API Data Mapping Logic
* [ ] If separate functions are used to map brokerage API data to your database schema, write Jest tests for these mapping functions using mock API responses.
Task: Set up React Testing Library for Component Testing
* [ ] Install React Testing Library (npm install --save-dev @testing-library/react @testing-library/jest-dom).
* [ ] Configure Jest to use React Testing Library matchers.
Task: Write Integration Tests for Trade Entry Form & Save
* [ ] Write tests using React Testing Library to simulate user interaction with the Trade Entry form.
* [ ] Mock the Supabase data access function calls to verify that the correct data is being prepared and passed for saving.
Task: Write Integration Tests for Data Fetching and Display (e.g., Active Trades)
* [ ] Write tests to verify that components (e.g., Active Trades page) correctly fetch data from mocked Supabase functions and display it in the UI.
Task: Set up Cypress for End-to-End Testing
* [ ] Install Cypress (npm install --save-dev cypress).
* [ ] Configure Cypress for your Next.js project.
Task: Write E2E Test for User Signup Flow
* [ ] Write a Cypress test script to simulate a new user signing up, including filling the form and clicking the submit button. (Note: Email verification might need to be mocked or handled carefully in E2E).
Task: Write E2E Test for User Login Flow
* [ ] Write a Cypress test script to simulate an existing user logging in and verifying they are redirected to the dashboard.
Task: Write E2E Test for Logging a Manual Trade
* [ ] Write a Cypress test script to simulate navigating to the Log Trade page, filling out the manual trade entry form, submitting it, and verifying the trade appears in the Active Trades list.
Task: Add Code Comments for Complex Logic
* [ ] Review the codebase, particularly in calculation functions, API route handlers, and data mapping logic.
* [ ] Add clear and concise comments explaining the purpose and implementation details of complex sections.
Task: Create Initial README File
* [ ] Create a README.md file in the project root.
* [ ] Include a project title and brief description.
* [ ] Add sections for Technology Stack, Setup Instructions (including environment variables and Supabase setup), and Running the Project.
Task: Document Database Schema
* [ ] Create a docs/database-schema.md file.
* [ ] Document each table (users, brokerages, user_brokerage_accounts, trades, assignments, watchlist), listing columns, data types, constraints (PK, FK, unique), and a brief description of its purpose.
Task: Document Internal API Route Specifications
* [ ] Create a docs/api-specs.md file.
* [ ] Document each internal API route (/api/marketdata/..., /api/brokerage/...).
* [ ] For each route, specify the HTTP method (GET, POST), endpoint path, required query parameters or request body, expected response format (including TypeScript interfaces), and potential error responses.
Task: Prepare Project for Vercel/Netlify Deployment
* [ ] Ensure the project is configured for serverless deployment (standard for Next.js App Router).
* [ ] Verify that environment variables are correctly accessed on the server side and client side where needed (using NEXT_PUBLIC_ prefix for client-side).
Task: Configure Environment Variables for Production Deployment
* [ ] (Note: This step is manual in the deployment platform's UI) Add the production values for environment variables (Supabase keys, API keys, Resend key) in the Vercel/Netlify dashboard settings.
Task: (Wheel Specific) Implement Logic for Premium Collected vs Assignment Cost Chart Data
* [ ] Create a function to process closed Wheel cycles data.
* [ ] For each completed cycle, calculate the total premium collected and the assignment cost basis.
* [ ] Format this data into a structure suitable for the charting library (Task 103).

